{
    "sourceFile": "dynamic_core.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 165,
            "patches": [
                {
                    "date": 1683568461415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1683568469761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,1 @@\n-#include <bits\n\\ No newline at end of file\n+#include <bits/stdc++.h>\r\n"
                },
                {
                    "date": 1683568507123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,1 @@\n-#include <bits/stdc++.h>\r\n+#include <bits/std.h>\r\n"
                },
                {
                    "date": 1683568596409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,1 @@\n-#include <bits/std.h>\r\n+#include <ios>\r\n"
                },
                {
                    "date": 1683568602081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2 @@\n+#include <iostream>\r\n+\r\n"
                },
                {
                    "date": 1683568608981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,3 @@\n+#include <iostream>\r\n+\r\n+\r\n"
                },
                {
                    "date": 1683568623776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,3 @@\n+#include <iostream>\r\n+\r\n+int \r\n"
                },
                {
                    "date": 1683569005642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,5 @@\n #include <iostream>\r\n \r\n-int \r\n-#include <iostream>\r\n-\r\n-\r\n-#include <iostream>\r\n-\r\n-#include <ios>\r\n+struct ans{\r\n+    \r\n+}\r\n"
                },
                {
                    "date": 1683569012897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n #include <iostream>\r\n \r\n struct ans{\r\n-    \r\n+    float \r\n }\r\n"
                },
                {
                    "date": 1683569020655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n #include <iostream>\r\n \r\n struct ans{\r\n-    float \r\n+    float b\r\n }\r\n"
                },
                {
                    "date": 1683569028737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n #include <iostream>\r\n \r\n struct ans{\r\n-    float b\r\n+    float b_each;\r\n+    float s[]\r\n }\r\n"
                },
                {
                    "date": 1683569037405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n #include <iostream>\r\n \r\n struct ans{\r\n     float b_each;\r\n-    float s[]\r\n+    float s_each;\r\n+    float l_each;\r\n }\r\n"
                },
                {
                    "date": 1683569054868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,5 +3,5 @@\n struct ans{\r\n     float b_each;\r\n     float s_each;\r\n     float l_each;\r\n-}\r\n+};\r\n"
                },
                {
                    "date": 1683569065190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,9 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans \r\n"
                },
                {
                    "date": 1683569073498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,11 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost{\r\n+    \r\n+}\r\n"
                },
                {
                    "date": 1683569086428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,22 +6,7 @@\n     float l_each;\r\n };\r\n \r\n ans dynamic_cost{\r\n+    ans result;\r\n     \r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans \r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n"
                },
                {
                    "date": 1683569100907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,8 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost{\r\n+ans dynamic_cost(){\r\n     ans result;\r\n-    \r\n+\r\n }\r\n"
                },
                {
                    "date": 1683569114557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,8 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost(){\r\n+ans dynamic_cost(int){\r\n     ans result;\r\n \r\n }\r\n"
                },
                {
                    "date": 1683569135213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int** b, int){\r\n+    ans result;\r\n+\r\n+}\r\n"
                },
                {
                    "date": 1683569142189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int){\r\n+    ans result;\r\n+\r\n+}\r\n"
                },
                {
                    "date": 1683569160799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,32 +5,8 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost(int* b, int){\r\n+ans dynamic_cost(int* b, int* s, int l){\r\n     ans result;\r\n \r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int** b, int){\r\n-    ans result;\r\n-\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int){\r\n-    ans result;\r\n-\r\n-}\r\n"
                },
                {
                    "date": 1683569166003,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,8 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost(int* b, int* s, int l){\r\n+ans dynamic_cost(int* b, int* s, int l_modify, ){\r\n     ans result;\r\n \r\n }\r\n"
                },
                {
                    "date": 1683569173248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,8 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost(int* b, int* s, int l_modify, ){\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n     ans result;\r\n \r\n }\r\n"
                },
                {
                    "date": 1683569185600,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j; j<)\r\n+}\r\n"
                },
                {
                    "date": 1683569198435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,14 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        \r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569210955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        # 是否更新bmax\r\n+        \r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569216248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569233733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+        \r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569246916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float *b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569253901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float *b_each;\r\n+    float*s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569260179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,15 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    floatl_each;\r\n+};\r\n+\r\n+ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+    ans result;\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569278387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,127 +2,14 @@\n \r\n struct ans{\r\n     float b_each;\r\n     float s_each;\r\n-    floatl_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float *b_each;\r\n-    float*s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float *b_each;\r\n-    float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n+ans dynamic_core(int* b, int* s, int l_modify, int j_upper){\r\n     ans result;\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-        \r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        # 是否更新bmax\r\n-        \r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j=2; j<j_upper; j++){\r\n-        \r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-    for (int j; j<)\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_cost(int* b, int* s, int l_modify, int j_upper){\r\n-    ans result;\r\n-\r\n-}\r\n"
                },
                {
                    "date": 1683569307299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_core(int* b, int* s, int l_modify, int j_upper){\r\n+ans dynamic_core(int* b, int* s, int l_modify,  int j_upper){\r\n     ans result;\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569318090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_core(int* b, int* s, int l_modify,  int j_upper){\r\n+ans dynamic_core(int* b, int* s, int l_modify, int  int j_upper){\r\n     ans result;\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569324411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n-ans dynamic_core(int* b, int* s, int l_modify, int  int j_upper){\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569358681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n };\r\n \r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n+    \r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n"
                },
                {
                    "date": 1683569365419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n };\r\n \r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n-    \r\n+    int j_upper\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n"
                },
                {
                    "date": 1683569370961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n };\r\n \r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n-    int j_upper\r\n+    int j_upper = \r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n"
                },
                {
                    "date": 1683569378663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n };\r\n \r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n+    \r\n     int j_upper = \r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569384073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n };\r\n \r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n-    \r\n+    int lmax = 256; \r\n     int j_upper = \r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569392031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,17 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int j_upper = \r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569404779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; //\r\n+    int j_upper = \r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569443413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    \r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569451663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,18 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569457443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,80 +9,10 @@\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n     int header = 11; // 段首大小\r\n-    for (int i=1)\r\n+    for (int i=1; )\r\n     for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    \r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; //\r\n-    int j_upper = \r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int j_upper = \r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; \r\n-    int j_upper = \r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569471748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n     float s_each;\r\n     float l_each;\r\n };\r\n \r\n+\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n     int header = 11; // 段首大小\r\n"
                },
                {
                    "date": 1683569485012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,21 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 原python代码gai\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; )\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569492461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * \r\n+ * 注：原python代码改C\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; )\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569499636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划\r\n+ * 注：原python代码改C\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; )\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569518903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; )\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569532301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569539185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,24 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ * @return\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569544536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,24 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ * @returns\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569550688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,25 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ * b - b\r\n+ * @return\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569558076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n /**\r\n  * 动态规划算法-主体部分\r\n  * 注：原python代码改C\r\n  * @param\r\n- * b - b\r\n+ * b - python中的b数组\r\n  * @return\r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n@@ -22,180 +22,4 @@\n         // 是否更新bmax\r\n \r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- * @returns\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- * @return\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; )\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划\r\n- * 注：原python代码改C\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; )\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * \r\n- * 注：原python代码改C\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; )\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 原python代码gai\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; )\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; )\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569565277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,26 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s\r\n+ * @return\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569574589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,10 @@\n  * 动态规划算法-主体部分\r\n  * 注：原python代码改C\r\n  * @param\r\n  *  b - python中的b数组\r\n- *  s\r\n+ *  s - s数组\r\n+ *  l_modify\r\n  * @return\r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n@@ -23,29 +24,4 @@\n         // 是否更新bmax\r\n \r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- * b - python中的b数组\r\n- * @return\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569579744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n  * 注：原python代码改C\r\n  * @param\r\n  *  b - python中的b数组\r\n  *  s - s数组\r\n- *  l_modify\r\n+ *  length \r\n  * @return\r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n"
                },
                {
                    "date": 1683569588784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,10 +11,11 @@\n  * 注：原python代码改C\r\n  * @param\r\n  *  b - python中的b数组\r\n  *  s - s数组\r\n- *  length \r\n+ *  length - b和s数组的长度\r\n  * @return\r\n+ * \r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n"
                },
                {
                    "date": 1683569599178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,28 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result - \r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569604837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,28 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float b_each;\r\n+    float s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - \r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569611128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n  *  b - python中的b数组\r\n  *  s - s数组\r\n  *  length - b和s数组的长度\r\n  * @return\r\n- *  result(ans结构体) - \r\n+ *  result(ans结构体) - 包含b\r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n@@ -25,60 +25,4 @@\n         // 是否更新bmax\r\n \r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result - \r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- * \r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569619082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n  *  b - python中的b数组\r\n  *  s - s数组\r\n  *  length - b和s数组的长度\r\n  * @return\r\n- *  result(ans结构体) - 包含b\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n */\r\n ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n"
                },
                {
                    "date": 1683569625269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,28 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569674368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,28 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++)\r\n+    for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569679917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,26 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569685705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        \r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569691184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,121 +20,11 @@\n     ans result;\r\n     int lmax = 256; // 每段所包含元素的最大个数\r\n     int header = 11; // 段首大小\r\n     for (int i=1; i<length; i++){\r\n-        \r\n+        int j_upper = \r\n         for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float b_each;\r\n-    float s_each;\r\n-    float l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<)\r\n-    for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569700247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = lmax\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569712421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = lmax+1\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569717880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = (lmax+1>\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569724561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = (lmax+1)<i\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569729685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = (lmax+1)<(i+1)\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569736518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = (lmax+1)<(i+1)?lmax+1\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569745718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569756913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569768951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        bmax =\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569775774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,32 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        bmax = b[i];\r\n+        \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569781776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,32 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        int bmax = b[i];\r\n+        \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569789660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,32 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+    }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569798941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,378 +21,12 @@\n     int lmax = 256; // 每段所包含元素的最大个数\r\n     int header = 11; // 段首大小\r\n     for (int i=1; i<length; i++){\r\n         float bmax = b[i];\r\n-        \r\n+        float smin = s[i];\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n     }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int bmax = b[i];\r\n-        \r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        bmax = b[i];\r\n-        \r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        bmax =\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        \r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = (lmax+1)<(i+1)?lmax+1\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = (lmax+1)<(i+1)\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = (lmax+1)<i\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = (lmax+1>\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = lmax+1\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = lmax\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        int j_upper = \r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-    }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569813654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,7 +26,7 @@\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n+        }\r\n     }\r\n-    }\r\n }\r\n"
                },
                {
                    "date": 1683569824272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,9 @@\n     int header = 11; // 段首大小\r\n     for (int i=1; i<length; i++){\r\n         float bmax = b[i];\r\n         float smin = s[i];\r\n+        l_modify = 1;\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n"
                },
                {
                    "date": 1683569831568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569839956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        modify_flag = \r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+        // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569848959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,79 +23,12 @@\n     for (int i=1; i<length; i++){\r\n         float bmax = b[i];\r\n         float smin = s[i];\r\n         float l_modify = 1.0;\r\n-        modify_flag = \r\n+        boolean modify_flag = false;\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n         // 是否更新bmax\r\n \r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        \r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        l_modify = 1;\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569874550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false;\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569884188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569890512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否false\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569897559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 是否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569902874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569909821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,35 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+\r\n+            // 判断能否更新\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569916557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,35 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+\r\n+            // 判断能否更新\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569930375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,247 +28,8 @@\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n             // 判断能否更新bmax\r\n \r\n-            // 判断能否更新\r\n+            // 判断能否更新b,l,s\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-\r\n-            // 判断能否更新\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否false\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false;\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        boolean modify_flag = false;\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-        // 是否更新bmax\r\n-\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683569966297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,10 @@\n         bool modify_flag = false; //是否更新数组，默认为否（false）\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n             // 判断能否更新bmax\r\n-\r\n+            if bmax < p[i - j + 1]:\r\n+            #         bmax = p[i - j + 1]\r\n             // 判断能否更新b,l,s\r\n         }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1683569973435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,10 +27,10 @@\n         bool modify_flag = false; //是否更新数组，默认为否（false）\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n             // 判断能否更新bmax\r\n-            if bmax < p[i - j + 1]:\r\n-            #         bmax = p[i - j + 1]\r\n+            if (bmax < p[i - j + 1]:\r\n+            bmax = p[i - j + 1]\r\n             // 判断能否更新b,l,s\r\n         }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1683569979109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n         bool modify_flag = false; //是否更新数组，默认为否（false）\r\n         int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n         for (int j=2; j<j_upper; j++){\r\n             // 判断能否更新bmax\r\n-            if (bmax < p[i - j + 1]:\r\n+            if (bmax < p[i - j + 1])\r\n             bmax = p[i - j + 1]\r\n             // 判断能否更新b,l,s\r\n         }\r\n     }\r\n"
                },
                {
                    "date": 1683569984337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,36 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j + 1])\r\n+            bmax = p[i - j + 1]\r\n+            // 判断能否更新b,l,s\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569991436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,36 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1]\r\n+            // 判断能否更新b,l,s\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683569998027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            \r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570003140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if ()\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570010247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,37 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[])\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570018944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,190 +30,8 @@\n             // 判断能否更新bmax\r\n             if (bmax < b[i-j+1])\r\n                 bmax = b[i - j + 1];\r\n             // 判断能否更新b,l,s\r\n-            if (smin>s[])\r\n+            if (smin>s[i-j]+j*bmax+header)\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if ()\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            \r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1]\r\n-            // 判断能否更新b,l,s\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j + 1])\r\n-            bmax = p[i - j + 1]\r\n-            // 判断能否更新b,l,s\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < p[i - j + 1])\r\n-            bmax = p[i - j + 1]\r\n-            // 判断能否更新b,l,s\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570028662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                            #         smin = s[i - j] + j * bmax + header\r\n+            #         l_modify = j\r\n+            #         modify_flag=True\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570034964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,48 +31,11 @@\n             if (bmax < b[i-j+1])\r\n                 bmax = b[i - j + 1];\r\n             // 判断能否更新b,l,s\r\n             if (smin>s[i-j]+j*bmax+header){\r\n-                            #         smin = s[i - j] + j * bmax + header\r\n+                smin = s[i - j] + j * bmax + header;\r\n             #         l_modify = j\r\n             #         modify_flag=True\r\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header)\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570041039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n                 bmax = b[i - j + 1];\r\n             // 判断能否更新b,l,s\r\n             if (smin>s[i-j]+j*bmax+header){\r\n                 smin = s[i - j] + j * bmax + header;\r\n-            #         l_modify = j\r\n+                l_modify = j;\r\n             #         modify_flag=True\r\n             }\r\n         }\r\n     }\r\n"
                },
                {
                    "date": 1683570046786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag=\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570059455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,50 +33,10 @@\n             // 判断能否更新b,l,s\r\n             if (smin>s[i-j]+j*bmax+header){\r\n                 smin = s[i - j] + j * bmax + header;\r\n                 l_modify = j;\r\n-                modify_flag=\r\n+                modify_flag = true;\r\n             }\r\n+            //\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-            #         modify_flag=True\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570065637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570074540,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            \r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570082611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (mod)\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570088256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,45 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                b[]\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570094456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,45 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                ans.\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570119486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,224 +37,9 @@\n                 modify_flag = true;\r\n             }\r\n             // 对modify_flag=True的情况下更新\r\n             if (modify_flag){\r\n-                ans.\r\n+                //???\r\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                b[]\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (mod)\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            \r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            //\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570125524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n                 modify_flag = true;\r\n             }\r\n             // 对modify_flag=True的情况下更新\r\n             if (modify_flag){\r\n-                //???\r\n+                //TODO \r\n             }\r\n         }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1683570132699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,45 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 初始化\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570581564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                \r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570586871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b_each;\r\n+    float* s_each;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result.\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570604444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l_each;\r\n+};\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result.\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570611509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n \r\n struct ans{\r\n     float* b;\r\n     float* s;\r\n-    float* l_each;\r\n+    float* l;\r\n };\r\n \r\n /**\r\n  * 动态规划算法-主体部分\r\n@@ -38,191 +38,9 @@\n             }\r\n             // 对modify_flag=True的情况下更新\r\n             if (modify_flag){\r\n                 //TODO 指针数组初始化\r\n-                result.\r\n+                result.b = \r\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result.\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 初始化\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b_each;\r\n-    float* s_each;\r\n-    float* l_each;\r\n-};\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570625607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n     float* s;\r\n     float* l;\r\n };\r\n \r\n+\r\n /**\r\n  * 动态规划算法-主体部分\r\n  * 注：原python代码改C\r\n  * @param\r\n"
                },
                {
                    "date": 1683570631000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n     float* s;\r\n     float* l;\r\n };\r\n \r\n-\r\n+ans \r\n /**\r\n  * 动态规划算法-主体部分\r\n  * 注：原python代码改C\r\n  * @param\r\n"
                },
                {
                    "date": 1683570638686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,47 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans )\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result.b = \r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570653715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return ans\r\n+}\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result.b = \r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570658914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return re\r\n+}\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result.b = \r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570667684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return result;\r\n+}\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result \r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570674060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return result;\r\n+}\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result = init(re)\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570683594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,52 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result = init(result);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570688769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,55 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * \r\n+*/\r\n+ans init(ans result){\r\n+    ans result;\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                //TODO 指针数组初始化\r\n+                result = init(result);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570698114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n     float* l;\r\n };\r\n \r\n /**\r\n- * \r\n+ * 指针初始化\r\n */\r\n ans init(ans result){\r\n     ans result;\r\n \r\n@@ -46,360 +46,9 @@\n                 modify_flag = true;\r\n             }\r\n             // 对modify_flag=True的情况下更新\r\n             if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n                 result = init(result);\r\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result = init(result);\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return result;\r\n-}\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result = init(re)\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return result;\r\n-}\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return re\r\n-}\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result.b = \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return ans\r\n-}\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result.b = \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans init(ans )\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result.b = \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-ans \r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                //TODO 指针数组初始化\r\n-                result.b = \r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570706583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+                    //TODO 指针数组初始化\r\n+    ans result;\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570729452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    ans.b = \r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570738434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n */\r\n ans init(ans result){\r\n     //TODO 指针数组初始化\r\n     ans result;\r\n-    ans.b = \r\n+    ans.b = ()\r\n     return result;\r\n }\r\n \r\n /**\r\n@@ -54,115 +54,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-                    //TODO 指针数组初始化\r\n-    ans result;\r\n-\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    ans result;\r\n-\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570744129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n */\r\n ans init(ans result){\r\n     //TODO 指针数组初始化\r\n     ans result;\r\n-    ans.b = ()\r\n+    ans->b = ()\r\n     return result;\r\n }\r\n \r\n /**\r\n"
                },
                {
                    "date": 1683570885677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    struct ans* ptr = (struct ans*) malloc(sizeof(struct ans));\r\n+    ans->b = ();\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570900961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    struct ans* result = (struct ans*) malloc(sizeof(struct ans));\r\n+    result->b = ();\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570920184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    struct ans* result = (struct ans*) malloc(sizeof(struct ans));\r\n+    if (result!=null)\r\n+    result->b = ();\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570932366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,67 +10,12 @@\n  * 指针初始化\r\n */\r\n ans init(ans result){\r\n     //TODO 指针数组初始化\r\n-    struct ans* result = (struct ans*) malloc(sizeof(struct ans));\r\n-    if (result!=null)\r\n-    result->b = ();\r\n-    return result;\r\n-}\r\n+    ans result = (struct ans*) malloc(sizeof(struct ans));\r\n+    if (result!=NULL){\r\n \r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n     }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    struct ans* result = (struct ans*) malloc(sizeof(struct ans));\r\n     result->b = ();\r\n     return result;\r\n }\r\n \r\n@@ -112,118 +57,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    struct ans* ptr = (struct ans*) malloc(sizeof(struct ans));\r\n-    ans->b = ();\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    ans->b = ()\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683570940227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result->b = ();\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683570993504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n */\r\n ans init(ans result){\r\n     //TODO 指针数组初始化\r\n     ans result;\r\n-    result->b = ();\r\n+    result.b = ( (float*) calloc(10, sizeof(float)));\r\n     return result;\r\n }\r\n \r\n /**\r\n@@ -54,64 +54,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result = (struct ans*) malloc(sizeof(struct ans));\r\n-    if (result!=NULL){\r\n-\r\n-    }\r\n-    result->b = ();\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683571016069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) alloc(10, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571021878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+#include \r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) alloc(10, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571029263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+#include <stdib.\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) alloc(10, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571047748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <iostream>\r\n+#include <stdlib.h>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) alloc(, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571087717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,58 @@\n+#include <iostream>\r\n+#include <stdlib.h>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) malloc(, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571094275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,5 @@\n #include <iostream>\r\n-#include <stdlib.h>\r\n \r\n struct ans{\r\n     float* b;\r\n     float* s;\r\n@@ -55,290 +54,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-#include <stdlib.h>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) alloc(, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-#include <stdib.\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) alloc(10, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-#include \r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) alloc(10, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) alloc(10, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b = ( (float*) calloc(10, sizeof(float)));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683571101285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) malloc(len, sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571109729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) malloc(length);\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571125047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    //TODO 指针数组初始化\r\n+    ans result;\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571132573,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n ans init(ans result, int length){\r\n     //TODO 指针数组初始化\r\n     ans result;\r\n     result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n     return result;\r\n }\r\n \r\n /**\r\n@@ -54,175 +55,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) malloc(length);\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) malloc(len, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result){\r\n-    //TODO 指针数组初始化\r\n-    ans result;\r\n-    result.b =  (float*) malloc(, sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683571141504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,12 @@\n /**\r\n  * 指针初始化\r\n */\r\n ans init(ans result, int length){\r\n-    //TODO 指针数组初始化\r\n     ans result;\r\n     result.b =  (float*) malloc(length*sizeof(float));\r\n     result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n     return result;\r\n }\r\n \r\n /**\r\n"
                },
                {
                    "date": 1683571152114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n  * 指针初始化\r\n */\r\n ans init(ans result, int length){\r\n     ans result;\r\n+    // malloc分配内存空间\r\n     result.b =  (float*) malloc(length*sizeof(float));\r\n     result.s =  (float*) malloc(length*sizeof(float));\r\n     result.l =  (float*) malloc(length*sizeof(float));\r\n     return result;\r\n"
                },
                {
                    "date": 1683571160579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571170566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,60 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // \r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571176650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,60 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // \r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571189518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    \r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571201421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571215488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n     result.s =  (float*) malloc(length*sizeof(float));\r\n     result.l =  (float*) malloc(length*sizeof(float));\r\n     // 初始化\r\n     result.b[0] = 0\r\n+    result.b[0] = 0\r\n     return result;\r\n }\r\n \r\n /**\r\n@@ -58,303 +59,4 @@\n             }\r\n         }\r\n     }\r\n }\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    ans result;\r\n-    // malloc 分配内存空间\r\n-    result.b =  (float*) malloc(length*sizeof(float));\r\n-    result.s =  (float*) malloc(length*sizeof(float));\r\n-    result.l =  (float*) malloc(length*sizeof(float));\r\n-    // 初始化\r\n-    \r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    ans result;\r\n-    // malloc 分配内存空间\r\n-    result.b =  (float*) malloc(length*sizeof(float));\r\n-    result.s =  (float*) malloc(length*sizeof(float));\r\n-    result.l =  (float*) malloc(length*sizeof(float));\r\n-    // \r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    ans result;\r\n-    // malloc 分配内存空间\r\n-    result.b =  (float*) malloc(length*sizeof(float));\r\n-    result.s =  (float*) malloc(length*sizeof(float));\r\n-    result.l =  (float*) malloc(length*sizeof(float));\r\n-    // \r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    ans result;\r\n-    // malloc 分配内存空间\r\n-    result.b =  (float*) malloc(length*sizeof(float));\r\n-    result.s =  (float*) malloc(length*sizeof(float));\r\n-    result.l =  (float*) malloc(length*sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-#include <iostream>\r\n-\r\n-struct ans{\r\n-    float* b;\r\n-    float* s;\r\n-    float* l;\r\n-};\r\n-\r\n-/**\r\n- * 指针初始化\r\n-*/\r\n-ans init(ans result, int length){\r\n-    ans result;\r\n-    // malloc分配内存空间\r\n-    result.b =  (float*) malloc(length*sizeof(float));\r\n-    result.s =  (float*) malloc(length*sizeof(float));\r\n-    result.l =  (float*) malloc(length*sizeof(float));\r\n-    return result;\r\n-}\r\n-\r\n-/**\r\n- * 动态规划算法-主体部分\r\n- * 注：原python代码改C\r\n- * @param\r\n- *  b - python中的b数组\r\n- *  s - s数组\r\n- *  length - b和s数组的长度\r\n- * @return\r\n- *  result(ans结构体) - 包含新的b, s, l数组\r\n-*/\r\n-ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n-    ans result;\r\n-    int lmax = 256; // 每段所包含元素的最大个数\r\n-    int header = 11; // 段首大小\r\n-    for (int i=1; i<length; i++){\r\n-        float bmax = b[i];\r\n-        float smin = s[i];\r\n-        float l_modify = 1.0;\r\n-        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n-        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n-        for (int j=2; j<j_upper; j++){\r\n-            // 判断能否更新bmax\r\n-            if (bmax < b[i-j+1])\r\n-                bmax = b[i - j + 1];\r\n-            // 判断能否更新b,l,s\r\n-            if (smin>s[i-j]+j*bmax+header){\r\n-                smin = s[i - j] + j * bmax + header;\r\n-                l_modify = j;\r\n-                modify_flag = true;\r\n-            }\r\n-            // 对modify_flag=True的情况下更新\r\n-            if (modify_flag){\r\n-                result = init(result);\r\n-\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n"
                },
                {
                    "date": 1683571222398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    \r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571227739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571236963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result, le);\r\n+\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571250456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result, length);\r\n+                result.b[]\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571261368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result, length);\r\n+                result.b[i] = bmax;\r\n+                \r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571266919,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result, length);\r\n+                result.b[i] = bmax;\r\n+                result.s\r\n+\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1683571275269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n             if (modify_flag){\r\n                 result = init(result, length);\r\n                 result.b[i] = bmax;\r\n                 result.s[i] = smin;\r\n-                \r\n+                s\r\n             }\r\n         }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1683571282725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#include <iostream>\r\n+\r\n+struct ans{\r\n+    float* b;\r\n+    float* s;\r\n+    float* l;\r\n+};\r\n+\r\n+/**\r\n+ * 指针初始化\r\n+*/\r\n+ans init(ans result, int length){\r\n+    ans result;\r\n+    // malloc 分配内存空间\r\n+    result.b =  (float*) malloc(length*sizeof(float));\r\n+    result.s =  (float*) malloc(length*sizeof(float));\r\n+    result.l =  (float*) malloc(length*sizeof(float));\r\n+    // 初始化\r\n+    result.b[0] = 0;\r\n+    result.s[0] = 0;\r\n+    result.l[0] = 1;\r\n+    return result;\r\n+}\r\n+\r\n+/**\r\n+ * 动态规划算法-主体部分\r\n+ * 注：原python代码改C\r\n+ * @param\r\n+ *  b - python中的b数组\r\n+ *  s - s数组\r\n+ *  length - b和s数组的长度\r\n+ * @return\r\n+ *  result(ans结构体) - 包含新的b, s, l数组\r\n+*/\r\n+ans dynamic_core(int* b, int* s, int l_modify, int length){\r\n+    ans result;\r\n+    int lmax = 256; // 每段所包含元素的最大个数\r\n+    int header = 11; // 段首大小\r\n+    for (int i=1; i<length; i++){\r\n+        float bmax = b[i];\r\n+        float smin = s[i];\r\n+        float l_modify = 1.0;\r\n+        bool modify_flag = false; //是否更新数组，默认为否（false）\r\n+        int j_upper = (lmax+1)<(i+1)?(lmax+1):(i+1);\r\n+        for (int j=2; j<j_upper; j++){\r\n+            // 判断能否更新bmax\r\n+            if (bmax < b[i-j+1])\r\n+                bmax = b[i - j + 1];\r\n+            // 判断能否更新b,l,s\r\n+            if (smin>s[i-j]+j*bmax+header){\r\n+                smin = s[i - j] + j * bmax + header;\r\n+                l_modify = j;\r\n+                modify_flag = true;\r\n+            }\r\n+            // 对modify_flag=True的情况下更新\r\n+            if (modify_flag){\r\n+                result = init(result, length);\r\n+                result.b[i] = bmax;\r\n+                result.s[i] = smin;\r\n+                result.l[i]\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n"
                }
            ],
            "date": 1683568461415,
            "name": "Commit-0",
            "content": "#include <bits"
        }
    ]
}