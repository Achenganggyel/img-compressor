{
    "sourceFile": "materials/tmp_color.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 21,
            "patches": [
                {
                    "date": 1684513482220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684514812682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+\r\n '''\r\n 对图像进行压缩的软件\r\n @Authors:\r\n     Alla, ytding, xx, xx\r\n"
                },
                {
                    "date": 1684514826478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,422 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        f = open(\"output/result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"共分成\" + str(m) + \"段\" + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素\\t\\t\" + \"需要存储的位数为：\" + str(b[i]) + \"\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684515168399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,13 +166,13 @@\n         i = 0\r\n         f = open(\"output/result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"共分成\" + str(m) + \"段\" + \"\\n\")\r\n+f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n         for i in range(i + 1, m + 1):\r\n-            f.write(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素\\t\\t\" + \"需要存储的位数为：\" + str(b[i]) + \"\\n\")\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n         f.close()\r\n \r\n     '''\r\n         5/8 修改：加入彩色图像压缩部分\r\n@@ -419,426 +419,4 @@\n     # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n     # running_time = test.getRunningTime()  # 获取执行时间\r\n     # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n     # print(\"压缩算法执行时间：\" + str(running_time))\r\n-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, xx, xx\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        f = open(\"output/result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"共分成\" + str(m) + \"段\" + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素\\t\\t\" + \"需要存储的位数为：\" + str(b[i]) + \"\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684515175583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,9 +166,9 @@\n         i = 0\r\n         f = open(\"output/result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n-f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n         f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n         f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n         for i in range(i + 1, m + 1):\r\n             f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n"
                },
                {
                    "date": 1684519035786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,9 +163,9 @@\n     '''\r\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n-        f = open(\"output/result.txt\", \"w+\")\r\n+        f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n         f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n"
                },
                {
                    "date": 1684519130125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,8 +163,9 @@\n     '''\r\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n+        \r\n         f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n"
                },
                {
                    "date": 1684519139118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,423 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519146807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,8 +164,9 @@\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n         # 获取当前文件的路径\r\n+        base_\r\n         f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n@@ -420,427 +421,4 @@\n     # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n     # running_time = test.getRunningTime()  # 获取执行时间\r\n     # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n     # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        \r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519158050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,9 @@\n 如果修改了函数的输入输出，请在注释中写明\r\n 因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n '''\r\n import sys\r\n+import os\r\n import numpy as np\r\n from PyQt5.QtCore import QObject, pyqtSignal\r\n from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n import time\r\n@@ -164,9 +165,9 @@\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n         # 获取当前文件的路径\r\n-        base_\r\n+        base_path = \r\n         f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n"
                },
                {
                    "date": 1684519166240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n         # 获取当前文件的路径\r\n-        base_path = \r\n+        base_path = os.p\r\n         f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n"
                },
                {
                    "date": 1684519172452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,425 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname()\r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519234543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n \r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n         # 获取当前文件的路径\r\n-        base_path = os.path.dirname()\r\n+        base_path = os.path.dirname(os.path.)\r\n         f = open(\"result.txt\", \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n@@ -422,429 +422,4 @@\n     # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n     # running_time = test.getRunningTime()  # 获取执行时间\r\n     # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n     # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.p\r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519241612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,426 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname(os.path.abspath(__file__))\r\n+        \r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519250183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,426 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname(os.path.abspath(__file__))\r\n+        # \r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519261650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,427 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname(os.path.abspath(__file__))\r\n+        # 整合txt文件\r\n+        txt_path = os.path\r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519267967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,427 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname(os.path.abspath(__file__))\r\n+        # 整合txt文件\r\n+        txt_path = os.path.join(base_path, '')\r\n+        f = open(\"result.txt\", \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684519277873,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,10 +167,10 @@\n         i = 0\r\n         # 获取当前文件的路径\r\n         base_path = os.path.dirname(os.path.abspath(__file__))\r\n         # 整合txt文件\r\n-        txt_path = os.path.join(base_path, '')\r\n-        f = open(\"result.txt\", \"w+\")\r\n+        txt_path = os.path.join(base_path, 'result.txt')\r\n+        f = open(txt_path, \"w+\")\r\n         self.min_length = min_len\r\n         self.aver_bit = min_len / (512 * 512)\r\n         f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n         f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n@@ -424,1708 +424,4 @@\n     # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n     # running_time = test.getRunningTime()  # 获取执行时间\r\n     # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n     # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.path.dirname(os.path.abspath(__file__))\r\n-        # 整合txt文件\r\n-        txt_path = os.path\r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.path.dirname(os.path.abspath(__file__))\r\n-        # \r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.path.dirname(os.path.abspath(__file__))\r\n-        \r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.path.dirname(os.path.)\r\n-        f = open(\"result.txt\", \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684521391151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -263,9 +263,9 @@\n         # print(\"s array: \")\r\n         # print(s)\r\n         input_size = 512 * 512 * 24\r\n         output_size = s[n]\r\n-        self.compress_rate = output_size / input_size\r\n+        self.compress_rate = 1-output_size / input_size\r\n         return s\r\n \r\n \r\n '''\r\n"
                },
                {
                    "date": 1684533413591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,427 @@\n+# -*- coding : utf-8-*-\r\n+'''\r\n+对图像进行压缩的软件\r\n+@Authors:\r\n+    Alla, ytding, yxDu, hWu, yjMa\r\n+@class\r\n+    CompressPic 压缩图片的过程\r\n+    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n+\r\n+!!Attention!!\r\n+如果修改了函数的输入输出，请在注释中写明\r\n+因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n+'''\r\n+import sys\r\n+import os\r\n+import numpy as np\r\n+from PyQt5.QtCore import QObject, pyqtSignal\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n+import time\r\n+import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n+from PyQt5 import QtCore, QtGui, QtWidgets\r\n+from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n+'''\r\n+     5/8 改动部分：\r\n+        class CompressPic()中：\r\n+        添加成员变量color和彩色图像压缩compressColor()模块\r\n+        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n+        length();\r\n+        compress()中参数p相关的语句;\r\n+        compressPic()添加了彩色图像压缩部分；\r\n+'''\r\n+\r\n+\r\n+'''\r\n+图像压缩类\r\n+@params\r\n+    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n+@return\r\n+    compress_rate 压缩效率(getCompressRate函数)\r\n+    running_time 执行时间(getRunningTime函数)\r\n+'''\r\n+\r\n+\r\n+class CompressPic():\r\n+    def __init__(self, input_pic=None) -> None:\r\n+        self.input_pic = input_pic\r\n+        self.N = 512\r\n+        self.n = 512 * 512 + 1\r\n+        self.compress_rate = None\r\n+        self.running_time = None\r\n+        self.min_length = None\r\n+        self.aver_bit = None\r\n+        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n+        获得蛇形序列函数\r\n+    @return\r\n+        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n+    '''\r\n+\r\n+    def getSnakeOrder(self):\r\n+        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n+        snake_order.append([0, 0, 0])  # 下标从1开始\r\n+        flag = 1  # 用于控制蛇形输出的方向\r\n+        # 遍历图像的每一行\r\n+        for i in range(self.N):\r\n+            # 如果方向标志为1，则从左往右遍历该行的像素\r\n+            if flag == 1:\r\n+                for j in range(self.N):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n+            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n+            else:\r\n+                for j in range(self.N - 1, -1, -1):\r\n+                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n+                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n+                        self.color = 1\r\n+                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n+        return snake_order  # 返回包含所有像素的数组\r\n+\r\n+    '''\r\n+        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n+        @params \r\n+            i  像素值\r\n+        @return\r\n+            k 像素点所需要的存储位数\r\n+            '''\r\n+\r\n+    def length(self,i):\r\n+        k = 1\r\n+        i = i / 2\r\n+        while i > 0:\r\n+            k += 1\r\n+            i = i // 2\r\n+        return k\r\n+\r\n+    '''\r\n+        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n+        基于动态规划的图像压缩算法\r\n+        @params \r\n+            n  像素点的个数+1\r\n+            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n+            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            s(list)\r\n+        '''\r\n+    def compress(self, n, p, s, b, l):\r\n+        lmax = 256  # 每段所包含元素的最大个数\r\n+        header = 11  # 段首大小\r\n+        start_time = time.time()  # 记录开始执行时间\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax + header\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax + header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        input_size = 512 * 512 * 8\r\n+        output_size = s[self.n-1]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+    '''\r\n+        计算压缩后有多少段\r\n+         @params \r\n+            n  像素点的个数+1\r\n+            b(list)  b[i]记录第i段每个像素的位数\r\n+            l(list)   l[i]记录第i段有多少个像素\r\n+        @return\r\n+            i-1  压缩后的段数\r\n+    '''\r\n+    def traceBack(self, n, l, b):\r\n+        stack = []\r\n+        stack.append(l[n])\r\n+        stack.append(b[n])\r\n+        while n != 0:\r\n+            n = n - l[n]\r\n+            stack.append(l[n])\r\n+            stack.append(b[n])\r\n+        i = 0\r\n+        while len(stack) > 0:\r\n+            b[i] = stack[-1]\r\n+            stack.pop()\r\n+            l[i] = stack[-1]\r\n+            stack.pop()\r\n+            i += 1\r\n+        return i - 1\r\n+\r\n+    '''\r\n+        将压缩信息输出到output/result.txt文件中\r\n+    '''\r\n+\r\n+    def out(self, m, min_len, l, b):\r\n+        i = 0\r\n+        # 获取当前文件的路径\r\n+        base_path = os.path.dirname(os.path.abspath(__file__))\r\n+        # 整合txt文件\r\n+        txt_path = os.path.join(base_path, 'result.txt')\r\n+        f = open(txt_path, \"w+\")\r\n+        self.min_length = min_len\r\n+        self.aver_bit = min_len / (512 * 512)\r\n+        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n+        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n+        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n+        for i in range(i + 1, m + 1):\r\n+            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n+        f.close()\r\n+\r\n+    '''\r\n+        5/8 修改：加入彩色图像压缩部分\r\n+        对图像进行压缩\r\n+    '''\r\n+\r\n+    def compressPic(self):\r\n+        if self.input_pic is None:\r\n+            raise ValueError(\"Input picture is not provided\")\r\n+        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n+        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n+        b = [0] * self.n  # 记录第i段每个像素的位数\r\n+        l = [0] * self.n  # 记录第i段有多少个像素\r\n+        p =[]\r\n+        # 灰度图压缩\r\n+        if self.color == 0:\r\n+            print(\"开始进行灰度图片压缩\")\r\n+            for pix in img_list:\r\n+                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n+            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n+            # print(\"图像的灰度序列为：\")\r\n+            # for i in range(1, self.n):\r\n+            #     print(str(p[i]) + \" \")\r\n+            s = self.compress(self.n-1, p, s, b, l)\r\n+            m = self.traceBack(self.n-1, l, b)\r\n+            self.out(m, s[self.n - 1], l, b)\r\n+        if self.color == 1:\r\n+            print(\"开始进行彩色图片压缩\")\r\n+            color_p = []\r\n+            for pix in img_list:\r\n+                color_p.append(3*(self.length(max(pix))))\r\n+            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n+            m = self.traceBack(self.n-1,l,b)\r\n+            self.out(m, s[self.n-1], l, b)\r\n+\r\n+    '''\r\n+        返回压缩效率\r\n+    '''\r\n+\r\n+    def getCompressRate(self):\r\n+        return self.compress_rate\r\n+\r\n+    '''\r\n+        返回压缩算法执行时间\r\n+    '''\r\n+\r\n+    def getRunningTime(self):\r\n+        return self.running_time\r\n+\r\n+    def getminlen(self):\r\n+        return self.min_length\r\n+\r\n+    def getaverbit(self):\r\n+        return self.aver_bit\r\n+\r\n+    '''\r\n+            compressColor()    彩色图像压缩方法\r\n+            p=[ [b,g,r], ..., [b,g,r] ]\r\n+    '''\r\n+    def compressColor(self, n, p, s, b, l):\r\n+        start_time = time.time()\r\n+        lmax = 512 # 每段所包含像素的最大个数\r\n+        header = self.length(lmax)+self.length(max(p))\r\n+        s[0] = 0\r\n+        for i in range(1, n+1):\r\n+            b[i] = p[i]\r\n+            bmax = b[i]\r\n+            s[i] = s[i - 1] + bmax\r\n+            l[i] = 1\r\n+            for j in range(2, lmax + 1):\r\n+                if j <= i:\r\n+                    if bmax < p[i - j + 1]:\r\n+                        bmax = p[i - j + 1]\r\n+                    if s[i] > s[i - j] + j * bmax+header:\r\n+                        s[i] = s[i - j] + j * bmax + header\r\n+                        l[i] = j\r\n+                        b[i] = bmax\r\n+        self.running_time = time.time() - start_time\r\n+        # print(\"compress l array：\")\r\n+        # print(l)\r\n+        # print(\"b array：\")\r\n+        # print(b)\r\n+        # print(\"s array: \")\r\n+        # print(s)\r\n+        input_size = 512 * 512 * 24\r\n+        output_size = s[n]\r\n+        self.compress_rate = 1-output_size / input_size\r\n+        return s\r\n+\r\n+\r\n+'''\r\n+    功能入口\r\n+'''\r\n+\r\n+'''\r\n+    UI类\r\n+'''\r\n+\r\n+\r\n+class Ui_MainWindow(object):\r\n+\r\n+    def setupUi(self, MainWindow):\r\n+        MainWindow.setObjectName(\"MainWindow\")\r\n+        MainWindow.resize(1000, 700)\r\n+        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n+        self.centralwidget.setObjectName(\"centralwidget\")\r\n+\r\n+        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n+        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n+        # self.pushButton.setObjectName(\"pushButton\")\r\n+\r\n+        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n+        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n+\r\n+        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n+        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n+        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n+\r\n+        self.label = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n+        self.label.setObjectName(\"label\")\r\n+\r\n+        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n+        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n+        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n+        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n+        self.label_2.setObjectName(\"label_2\")\r\n+\r\n+        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n+        self.textBrowser.setObjectName(\"textBrowser\")\r\n+\r\n+        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n+        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n+        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n+\r\n+        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n+        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n+        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n+        self.label_image.setObjectName(\"label_image\")\r\n+        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n+\r\n+        MainWindow.setCentralWidget(self.centralwidget)\r\n+        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n+        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n+        self.menubar.setObjectName(\"menubar\")\r\n+        MainWindow.setMenuBar(self.menubar)\r\n+        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n+        self.statusbar.setObjectName(\"statusbar\")\r\n+        MainWindow.setStatusBar(self.statusbar)\r\n+\r\n+        self.retranslateUi(MainWindow)\r\n+        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n+\r\n+        # self.pushButton.clicked.connect(self.openImage)\r\n+\r\n+        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n+        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n+        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n+        self.label_imagePath.setWordWrap(True)\r\n+\r\n+        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n+        self.pushButton_compress.clicked.connect(self.compress)\r\n+\r\n+    def retranslateUi(self, MainWindow):\r\n+        _translate = QtCore.QCoreApplication.translate\r\n+        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n+        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n+        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n+        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n+        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n+        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n+        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n+        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n+\r\n+    def openImage(self):  # 选择本地图片上传\r\n+        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n+        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n+                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n+        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n+                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n+        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n+        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n+        return imgName\r\n+\r\n+    def saveImage(self):  # 保存图片到本地\r\n+        screen = QApplication.primaryScreen()\r\n+        pix = screen.grabWindow(self.label_image.winId())\r\n+        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n+        pix.save(fd)\r\n+\r\n+    def printf(self, mes):\r\n+        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n+        self.cursot = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot.End)\r\n+        # QtWidgets.QApplication.processEvents()\r\n+\r\n+    def printf2(self, mes2):\r\n+        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n+        self.cursot2 = self.textBrowser.textCursor()\r\n+        self.textBrowser.moveCursor(self.cursot2.End)\r\n+\r\n+    def compress(self):  # 压缩图片\r\n+        self.openImage()\r\n+        print(imgName)\r\n+        img = cv2.imread(imgName)\r\n+        test = CompressPic(img)\r\n+        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+        running_time = test.getRunningTime()  # 获取执行时间\r\n+        min_length = test.getminlen()\r\n+        aver_bit = test.getaverbit()\r\n+        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+        print(\"压缩算法执行时间：\" + str(running_time))\r\n+        print(\"最小长度：\" + str(min_length))\r\n+        print(\"平均每个像素：\" + str(aver_bit))\r\n+        Ui_MainWindow.printf(self, str(min_length))\r\n+        Ui_MainWindow.printf2(self, str(aver_bit))\r\n+\r\n+\r\n+if __name__ == '__main__':\r\n+    # 执行ui界面\r\n+    app = QtWidgets.QApplication(sys.argv)\r\n+    formObj = QtWidgets.QMainWindow()\r\n+    ui = Ui_MainWindow()\r\n+    ui.setupUi(formObj)\r\n+    formObj.show()\r\n+    sys.exit(app.exec_())\r\n+\r\n+    # compress test\r\n+    # img = cv2.imread(imgName, 0)\r\n+    # # print(\"img array: \")\r\n+    # # print(img)\r\n+    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n+    #\r\n+    # # 压缩调用示例如下\r\n+    # test = CompressPic(img)\r\n+    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n+    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n+    # running_time = test.getRunningTime()  # 获取执行时间\r\n+    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n+    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684582679602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -424,431 +424,4 @@\n     # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n     # running_time = test.getRunningTime()  # 获取执行时间\r\n     # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n     # print(\"压缩算法执行时间：\" + str(running_time))\r\n-# -*- coding : utf-8-*-\r\n-'''\r\n-对图像进行压缩的软件\r\n-@Authors:\r\n-    Alla, ytding, yxDu, hWu, yjMa\r\n-@class\r\n-    CompressPic 压缩图片的过程\r\n-    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n-\r\n-!!Attention!!\r\n-如果修改了函数的输入输出，请在注释中写明\r\n-因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n-'''\r\n-import sys\r\n-import os\r\n-import numpy as np\r\n-from PyQt5.QtCore import QObject, pyqtSignal\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\n-import time\r\n-import cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n-from PyQt5 import QtCore, QtGui, QtWidgets\r\n-from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n-'''\r\n-     5/8 改动部分：\r\n-        class CompressPic()中：\r\n-        添加成员变量color和彩色图像压缩compressColor()模块\r\n-        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n-        length();\r\n-        compress()中参数p相关的语句;\r\n-        compressPic()添加了彩色图像压缩部分；\r\n-'''\r\n-\r\n-\r\n-'''\r\n-图像压缩类\r\n-@params\r\n-    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n-@return\r\n-    compress_rate 压缩效率(getCompressRate函数)\r\n-    running_time 执行时间(getRunningTime函数)\r\n-'''\r\n-\r\n-\r\n-class CompressPic():\r\n-    def __init__(self, input_pic=None) -> None:\r\n-        self.input_pic = input_pic\r\n-        self.N = 512\r\n-        self.n = 512 * 512 + 1\r\n-        self.compress_rate = None\r\n-        self.running_time = None\r\n-        self.min_length = None\r\n-        self.aver_bit = None\r\n-        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n-        获得蛇形序列函数\r\n-    @return\r\n-        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n-    '''\r\n-\r\n-    def getSnakeOrder(self):\r\n-        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n-        snake_order.append([0, 0, 0])  # 下标从1开始\r\n-        flag = 1  # 用于控制蛇形输出的方向\r\n-        # 遍历图像的每一行\r\n-        for i in range(self.N):\r\n-            # 如果方向标志为1，则从左往右遍历该行的像素\r\n-            if flag == 1:\r\n-                for j in range(self.N):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n-            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n-            else:\r\n-                for j in range(self.N - 1, -1, -1):\r\n-                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n-                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n-                        self.color = 1\r\n-                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n-        return snake_order  # 返回包含所有像素的数组\r\n-\r\n-    '''\r\n-        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n-        @params \r\n-            i  像素值\r\n-        @return\r\n-            k 像素点所需要的存储位数\r\n-            '''\r\n-\r\n-    def length(self,i):\r\n-        k = 1\r\n-        i = i / 2\r\n-        while i > 0:\r\n-            k += 1\r\n-            i = i // 2\r\n-        return k\r\n-\r\n-    '''\r\n-        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n-        基于动态规划的图像压缩算法\r\n-        @params \r\n-            n  像素点的个数+1\r\n-            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n-            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            s(list)\r\n-        '''\r\n-    def compress(self, n, p, s, b, l):\r\n-        lmax = 256  # 每段所包含元素的最大个数\r\n-        header = 11  # 段首大小\r\n-        start_time = time.time()  # 记录开始执行时间\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax + header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        input_size = 512 * 512 * 8\r\n-        output_size = s[self.n-1]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-    '''\r\n-        计算压缩后有多少段\r\n-         @params \r\n-            n  像素点的个数+1\r\n-            b(list)  b[i]记录第i段每个像素的位数\r\n-            l(list)   l[i]记录第i段有多少个像素\r\n-        @return\r\n-            i-1  压缩后的段数\r\n-    '''\r\n-    def traceBack(self, n, l, b):\r\n-        stack = []\r\n-        stack.append(l[n])\r\n-        stack.append(b[n])\r\n-        while n != 0:\r\n-            n = n - l[n]\r\n-            stack.append(l[n])\r\n-            stack.append(b[n])\r\n-        i = 0\r\n-        while len(stack) > 0:\r\n-            b[i] = stack[-1]\r\n-            stack.pop()\r\n-            l[i] = stack[-1]\r\n-            stack.pop()\r\n-            i += 1\r\n-        return i - 1\r\n-\r\n-    '''\r\n-        将压缩信息输出到output/result.txt文件中\r\n-    '''\r\n-\r\n-    def out(self, m, min_len, l, b):\r\n-        i = 0\r\n-        # 获取当前文件的路径\r\n-        base_path = os.path.dirname(os.path.abspath(__file__))\r\n-        # 整合txt文件\r\n-        txt_path = os.path.join(base_path, 'result.txt')\r\n-        f = open(txt_path, \"w+\")\r\n-        self.min_length = min_len\r\n-        self.aver_bit = min_len / (512 * 512)\r\n-        f.write(\"the minimal length：\" + str(min_len) + \"\\n\")\r\n-        f.write(\"the average of bits each pixel needed to store：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n-        f.write(\"the whole number of segments:\" + str(m) + \"\\n\")\r\n-        for i in range(i + 1, m + 1):\r\n-            f.write(\"the \" + str(i) + \" segment\" + str(l[i]) + \"elements\\t\\t\" + \"which need to: \" + str(b[i]) + \" bit(s)\\n\")\r\n-        f.close()\r\n-\r\n-    '''\r\n-        5/8 修改：加入彩色图像压缩部分\r\n-        对图像进行压缩\r\n-    '''\r\n-\r\n-    def compressPic(self):\r\n-        if self.input_pic is None:\r\n-            raise ValueError(\"Input picture is not provided\")\r\n-        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n-        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n-        b = [0] * self.n  # 记录第i段每个像素的位数\r\n-        l = [0] * self.n  # 记录第i段有多少个像素\r\n-        p =[]\r\n-        # 灰度图压缩\r\n-        if self.color == 0:\r\n-            print(\"开始进行灰度图片压缩\")\r\n-            for pix in img_list:\r\n-                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n-            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n-            # print(\"图像的灰度序列为：\")\r\n-            # for i in range(1, self.n):\r\n-            #     print(str(p[i]) + \" \")\r\n-            s = self.compress(self.n-1, p, s, b, l)\r\n-            m = self.traceBack(self.n-1, l, b)\r\n-            self.out(m, s[self.n - 1], l, b)\r\n-        if self.color == 1:\r\n-            print(\"开始进行彩色图片压缩\")\r\n-            color_p = []\r\n-            for pix in img_list:\r\n-                color_p.append(3*(self.length(max(pix))))\r\n-            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n-            m = self.traceBack(self.n-1,l,b)\r\n-            self.out(m, s[self.n-1], l, b)\r\n-\r\n-    '''\r\n-        返回压缩效率\r\n-    '''\r\n-\r\n-    def getCompressRate(self):\r\n-        return self.compress_rate\r\n-\r\n-    '''\r\n-        返回压缩算法执行时间\r\n-    '''\r\n-\r\n-    def getRunningTime(self):\r\n-        return self.running_time\r\n-\r\n-    def getminlen(self):\r\n-        return self.min_length\r\n-\r\n-    def getaverbit(self):\r\n-        return self.aver_bit\r\n-\r\n-    '''\r\n-            compressColor()    彩色图像压缩方法\r\n-            p=[ [b,g,r], ..., [b,g,r] ]\r\n-    '''\r\n-    def compressColor(self, n, p, s, b, l):\r\n-        start_time = time.time()\r\n-        lmax = 512 # 每段所包含像素的最大个数\r\n-        header = self.length(lmax)+self.length(max(p))\r\n-        s[0] = 0\r\n-        for i in range(1, n+1):\r\n-            b[i] = p[i]\r\n-            bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax\r\n-            l[i] = 1\r\n-            for j in range(2, lmax + 1):\r\n-                if j <= i:\r\n-                    if bmax < p[i - j + 1]:\r\n-                        bmax = p[i - j + 1]\r\n-                    if s[i] > s[i - j] + j * bmax+header:\r\n-                        s[i] = s[i - j] + j * bmax + header\r\n-                        l[i] = j\r\n-                        b[i] = bmax\r\n-        self.running_time = time.time() - start_time\r\n-        # print(\"compress l array：\")\r\n-        # print(l)\r\n-        # print(\"b array：\")\r\n-        # print(b)\r\n-        # print(\"s array: \")\r\n-        # print(s)\r\n-        input_size = 512 * 512 * 24\r\n-        output_size = s[n]\r\n-        self.compress_rate = 1-output_size / input_size\r\n-        return s\r\n-\r\n-\r\n-'''\r\n-    功能入口\r\n-'''\r\n-\r\n-'''\r\n-    UI类\r\n-'''\r\n-\r\n-\r\n-class Ui_MainWindow(object):\r\n-\r\n-    def setupUi(self, MainWindow):\r\n-        MainWindow.setObjectName(\"MainWindow\")\r\n-        MainWindow.resize(1000, 700)\r\n-        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n-        self.centralwidget.setObjectName(\"centralwidget\")\r\n-\r\n-        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n-        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n-        # self.pushButton.setObjectName(\"pushButton\")\r\n-\r\n-        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n-        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n-\r\n-        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n-        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n-        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n-\r\n-        self.label = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n-        self.label.setObjectName(\"label\")\r\n-\r\n-        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n-        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n-        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n-        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n-        self.label_2.setObjectName(\"label_2\")\r\n-\r\n-        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n-        self.textBrowser.setObjectName(\"textBrowser\")\r\n-\r\n-        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n-        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n-        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n-\r\n-        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n-        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n-        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n-        self.label_image.setObjectName(\"label_image\")\r\n-        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n-\r\n-        MainWindow.setCentralWidget(self.centralwidget)\r\n-        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n-        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n-        self.menubar.setObjectName(\"menubar\")\r\n-        MainWindow.setMenuBar(self.menubar)\r\n-        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n-        self.statusbar.setObjectName(\"statusbar\")\r\n-        MainWindow.setStatusBar(self.statusbar)\r\n-\r\n-        self.retranslateUi(MainWindow)\r\n-        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n-\r\n-        # self.pushButton.clicked.connect(self.openImage)\r\n-\r\n-        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n-        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n-        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n-        self.label_imagePath.setWordWrap(True)\r\n-\r\n-        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n-        self.pushButton_compress.clicked.connect(self.compress)\r\n-\r\n-    def retranslateUi(self, MainWindow):\r\n-        _translate = QtCore.QCoreApplication.translate\r\n-        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n-        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n-        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n-        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n-        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n-        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n-        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n-        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n-\r\n-    def openImage(self):  # 选择本地图片上传\r\n-        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n-        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n-                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n-        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n-                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n-        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n-        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n-        return imgName\r\n-\r\n-    def saveImage(self):  # 保存图片到本地\r\n-        screen = QApplication.primaryScreen()\r\n-        pix = screen.grabWindow(self.label_image.winId())\r\n-        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n-        pix.save(fd)\r\n-\r\n-    def printf(self, mes):\r\n-        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n-        self.cursot = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot.End)\r\n-        # QtWidgets.QApplication.processEvents()\r\n-\r\n-    def printf2(self, mes2):\r\n-        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n-        self.cursot2 = self.textBrowser.textCursor()\r\n-        self.textBrowser.moveCursor(self.cursot2.End)\r\n-\r\n-    def compress(self):  # 压缩图片\r\n-        self.openImage()\r\n-        print(imgName)\r\n-        img = cv2.imread(imgName)\r\n-        test = CompressPic(img)\r\n-        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-        running_time = test.getRunningTime()  # 获取执行时间\r\n-        min_length = test.getminlen()\r\n-        aver_bit = test.getaverbit()\r\n-        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-        print(\"压缩算法执行时间：\" + str(running_time))\r\n-        print(\"最小长度：\" + str(min_length))\r\n-        print(\"平均每个像素：\" + str(aver_bit))\r\n-        Ui_MainWindow.printf(self, str(min_length))\r\n-        Ui_MainWindow.printf2(self, str(aver_bit))\r\n-\r\n-\r\n-if __name__ == '__main__':\r\n-    # 执行ui界面\r\n-    app = QtWidgets.QApplication(sys.argv)\r\n-    formObj = QtWidgets.QMainWindow()\r\n-    ui = Ui_MainWindow()\r\n-    ui.setupUi(formObj)\r\n-    formObj.show()\r\n-    sys.exit(app.exec_())\r\n-\r\n-    # compress test\r\n-    # img = cv2.imread(imgName, 0)\r\n-    # # print(\"img array: \")\r\n-    # # print(img)\r\n-    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n-    #\r\n-    # # 压缩调用示例如下\r\n-    # test = CompressPic(img)\r\n-    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n-    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n-    # running_time = test.getRunningTime()  # 获取执行时间\r\n-    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n-    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
                },
                {
                    "date": 1684586762522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n         s[0] = 0\r\n         for i in range(1, n+1):\r\n             b[i] = p[i]\r\n             bmax = b[i]\r\n-            s[i] = s[i - 1] + bmax + header\r\n+            s[i] = s[i - 1] + bmax\r\n             l[i] = 1\r\n             for j in range(2, lmax + 1):\r\n                 if j <= i:\r\n                     if bmax < p[i - j + 1]:\r\n"
                }
            ],
            "date": 1684513482220,
            "name": "Commit-0",
            "content": "'''\r\n对图像进行压缩的软件\r\n@Authors:\r\n    Alla, ytding, xx, xx\r\n@class\r\n    CompressPic 压缩图片的过程\r\n    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n\r\n!!Attention!!\r\n如果修改了函数的输入输出，请在注释中写明\r\n因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n'''\r\nimport sys\r\nimport numpy as np\r\nfrom PyQt5.QtCore import QObject, pyqtSignal\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\nimport time\r\nimport cv2  # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\nfrom PyQt5 import QtCore, QtGui, QtWidgets\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog\r\n'''\r\n     5/8 改动部分：\r\n        class CompressPic()中：\r\n        添加成员变量color和彩色图像压缩compressColor()模块\r\n        getSnakeOrder()添加了color变量值更新相关部分，返回变化snake_order=[[b,g,r], ..., [b,g,r]];\r\n        length();\r\n        compress()中参数p相关的语句;\r\n        compressPic()添加了彩色图像压缩部分；\r\n'''\r\n\r\n\r\n'''\r\n图像压缩类\r\n@params\r\n    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n@return\r\n    compress_rate 压缩效率(getCompressRate函数)\r\n    running_time 执行时间(getRunningTime函数)\r\n'''\r\n\r\n\r\nclass CompressPic():\r\n    def __init__(self, input_pic=None) -> None:\r\n        self.input_pic = input_pic\r\n        self.N = 512\r\n        self.n = 512 * 512 + 1\r\n        self.compress_rate = None\r\n        self.running_time = None\r\n        self.min_length = None\r\n        self.aver_bit = None\r\n        self.color = 0 # 5/8 20yjma添加 用于判断图像是彩色/灰度图，默认0（灰度图）\r\n\r\n    '''\r\n        5/8 修改by20yjma:添加了图像是否是彩色的记号变量self.color的更新\r\n        获得蛇形序列函数\r\n    @return\r\n        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n    '''\r\n\r\n    def getSnakeOrder(self):\r\n        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n        snake_order.append([0, 0, 0])  # 下标从1开始\r\n        flag = 1  # 用于控制蛇形输出的方向\r\n        # 遍历图像的每一行\r\n        for i in range(self.N):\r\n            # 如果方向标志为1，则从左往右遍历该行的像素\r\n            if flag == 1:\r\n                for j in range(self.N):\r\n                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n                        self.color = 1\r\n                flag -= 1  # 改变方向标志，以便下一行从右往左遍历\r\n            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n            else:\r\n                for j in range(self.N - 1, -1, -1):\r\n                    snake_order.append((self.input_pic[i][j]).tolist())  # 将该像素添加到输出数组中\r\n                    if self.color == 0 and len(set(self.input_pic[i][j])) != 1:\r\n                        self.color = 1\r\n                flag += 1  # 改变方向标志，以便下一行从左往右遍历\r\n        return snake_order  # 返回包含所有像素的数组\r\n\r\n    '''\r\n        计算像素值所需要的存储位数，即存储i，至少需要k位\r\n        @params \r\n            i  像素值\r\n        @return\r\n            k 像素点所需要的存储位数\r\n            '''\r\n\r\n    def length(self,i):\r\n        k = 1\r\n        i = i / 2\r\n        while i > 0:\r\n            k += 1\r\n            i = i // 2\r\n        return k\r\n\r\n    '''\r\n        5/8 修改by20yjma: p[i]是存储第i个像素点像素值所需的最小位数\r\n        基于动态规划的图像压缩算法\r\n        @params \r\n            n  像素点的个数+1\r\n            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n            b(list)  b[i]记录第i段每个像素的位数\r\n            l(list)   l[i]记录第i段有多少个像素\r\n        @return\r\n            s(list)\r\n        '''\r\n    def compress(self, n, p, s, b, l):\r\n        lmax = 256  # 每段所包含元素的最大个数\r\n        header = 11  # 段首大小\r\n        start_time = time.time()  # 记录开始执行时间\r\n        s[0] = 0\r\n        for i in range(1, n+1):\r\n            b[i] = p[i]\r\n            bmax = b[i]\r\n            s[i] = s[i - 1] + bmax + header\r\n            l[i] = 1\r\n            for j in range(2, lmax + 1):\r\n                if j <= i:\r\n                    if bmax < p[i - j + 1]:\r\n                        bmax = p[i - j + 1]\r\n                    if s[i] > s[i - j] + j * bmax + header:\r\n                        s[i] = s[i - j] + j * bmax + header\r\n                        l[i] = j\r\n                        b[i] = bmax\r\n        self.running_time = time.time() - start_time\r\n        input_size = 512 * 512 * 8\r\n        output_size = s[self.n-1]\r\n        self.compress_rate = 1-output_size / input_size\r\n        return s\r\n\r\n    '''\r\n        计算压缩后有多少段\r\n         @params \r\n            n  像素点的个数+1\r\n            b(list)  b[i]记录第i段每个像素的位数\r\n            l(list)   l[i]记录第i段有多少个像素\r\n        @return\r\n            i-1  压缩后的段数\r\n    '''\r\n    def traceBack(self, n, l, b):\r\n        stack = []\r\n        stack.append(l[n])\r\n        stack.append(b[n])\r\n        while n != 0:\r\n            n = n - l[n]\r\n            stack.append(l[n])\r\n            stack.append(b[n])\r\n        i = 0\r\n        while len(stack) > 0:\r\n            b[i] = stack[-1]\r\n            stack.pop()\r\n            l[i] = stack[-1]\r\n            stack.pop()\r\n            i += 1\r\n        return i - 1\r\n\r\n    '''\r\n        将压缩信息输出到output/result.txt文件中\r\n    '''\r\n\r\n    def out(self, m, min_len, l, b):\r\n        i = 0\r\n        f = open(\"output/result.txt\", \"w+\")\r\n        self.min_length = min_len\r\n        self.aver_bit = min_len / (512 * 512)\r\n        f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n        f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n        f.write(\"共分成\" + str(m) + \"段\" + \"\\n\")\r\n        for i in range(i + 1, m + 1):\r\n            f.write(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素\\t\\t\" + \"需要存储的位数为：\" + str(b[i]) + \"\\n\")\r\n        f.close()\r\n\r\n    '''\r\n        5/8 修改：加入彩色图像压缩部分\r\n        对图像进行压缩\r\n    '''\r\n\r\n    def compressPic(self):\r\n        if self.input_pic is None:\r\n            raise ValueError(\"Input picture is not provided\")\r\n        img_list = self.getSnakeOrder()  # 图像 RGB(list)\r\n        s = [0] * self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n        b = [0] * self.n  # 记录第i段每个像素的位数\r\n        l = [0] * self.n  # 记录第i段有多少个像素\r\n        p =[]\r\n        # 灰度图压缩\r\n        if self.color == 0:\r\n            print(\"开始进行灰度图片压缩\")\r\n            for pix in img_list:\r\n                p.append(self.length(pix[0]))  # 获取每个像素点，灰度值存储所需位数的列表p\r\n            # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n            # print(\"图像的灰度序列为：\")\r\n            # for i in range(1, self.n):\r\n            #     print(str(p[i]) + \" \")\r\n            s = self.compress(self.n-1, p, s, b, l)\r\n            m = self.traceBack(self.n-1, l, b)\r\n            self.out(m, s[self.n - 1], l, b)\r\n        if self.color == 1:\r\n            print(\"开始进行彩色图片压缩\")\r\n            color_p = []\r\n            for pix in img_list:\r\n                color_p.append(3*(self.length(max(pix))))\r\n            s = self.compressColor(self.n-1, color_p, s, b, l)\r\n            m = self.traceBack(self.n-1,l,b)\r\n            self.out(m, s[self.n-1], l, b)\r\n\r\n    '''\r\n        返回压缩效率\r\n    '''\r\n\r\n    def getCompressRate(self):\r\n        return self.compress_rate\r\n\r\n    '''\r\n        返回压缩算法执行时间\r\n    '''\r\n\r\n    def getRunningTime(self):\r\n        return self.running_time\r\n\r\n    def getminlen(self):\r\n        return self.min_length\r\n\r\n    def getaverbit(self):\r\n        return self.aver_bit\r\n\r\n    '''\r\n            compressColor()    彩色图像压缩方法\r\n            p=[ [b,g,r], ..., [b,g,r] ]\r\n    '''\r\n    def compressColor(self, n, p, s, b, l):\r\n        start_time = time.time()\r\n        lmax = 512 # 每段所包含像素的最大个数\r\n        header = self.length(lmax)+self.length(max(p))\r\n        s[0] = 0\r\n        for i in range(1, n+1):\r\n            b[i] = p[i]\r\n            bmax = b[i]\r\n            s[i] = s[i - 1] + bmax\r\n            l[i] = 1\r\n            for j in range(2, lmax + 1):\r\n                if j <= i:\r\n                    if bmax < p[i - j + 1]:\r\n                        bmax = p[i - j + 1]\r\n                    if s[i] > s[i - j] + j * bmax+header:\r\n                        s[i] = s[i - j] + j * bmax + header\r\n                        l[i] = j\r\n                        b[i] = bmax\r\n        self.running_time = time.time() - start_time\r\n        # print(\"compress l array：\")\r\n        # print(l)\r\n        # print(\"b array：\")\r\n        # print(b)\r\n        # print(\"s array: \")\r\n        # print(s)\r\n        input_size = 512 * 512 * 24\r\n        output_size = s[n]\r\n        self.compress_rate = output_size / input_size\r\n        return s\r\n\r\n\r\n'''\r\n    功能入口\r\n'''\r\n\r\n'''\r\n    UI类\r\n'''\r\n\r\n\r\nclass Ui_MainWindow(object):\r\n\r\n    def setupUi(self, MainWindow):\r\n        MainWindow.setObjectName(\"MainWindow\")\r\n        MainWindow.resize(1000, 700)\r\n        self.centralwidget = QtWidgets.QWidget(MainWindow)\r\n        self.centralwidget.setObjectName(\"centralwidget\")\r\n\r\n        # self.pushButton = QtWidgets.QPushButton(self.centralwidget)\r\n        # self.pushButton.setGeometry(QtCore.QRect(30, 50, 121, 51))\r\n        # self.pushButton.setObjectName(\"pushButton\")\r\n\r\n        self.pushButton_compress = QtWidgets.QPushButton(self.centralwidget)\r\n        self.pushButton_compress.setGeometry(QtCore.QRect(30, 170, 121, 51))\r\n        self.pushButton_compress.setObjectName(\"pushButton_compress\")\r\n\r\n        self.pushButton_saveImage = QtWidgets.QPushButton(self.centralwidget)\r\n        self.pushButton_saveImage.setGeometry(QtCore.QRect(30, 300, 121, 51))\r\n        self.pushButton_saveImage.setObjectName(\"pushButton_saveImage\")\r\n\r\n        self.label = QtWidgets.QLabel(self.centralwidget)\r\n        self.label.setGeometry(QtCore.QRect(40, 410, 91, 41))\r\n        self.label.setObjectName(\"label\")\r\n\r\n        # self.label_imagethen = QtWidgets.QLabel(self.centralwidget)\r\n        # self.label_imagethen.setGeometry(QtCore.QRect(1000, 40, 512, 512))\r\n        # self.label_imagethen.setFrameShape(QtWidgets.QFrame.Box)\r\n        # self.label_imagethen.setObjectName(\"label_imagethen\")\r\n        # self.label_imagethen.setScaledContents(True)  # 图片填充整个框\r\n\r\n        self.label_2 = QtWidgets.QLabel(self.centralwidget)\r\n        self.label_2.setGeometry(QtCore.QRect(40, 480, 91, 41))\r\n        self.label_2.setObjectName(\"label_2\")\r\n\r\n        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)\r\n        self.textBrowser.setGeometry(QtCore.QRect(120, 415, 191, 31))\r\n        self.textBrowser.setObjectName(\"textBrowser\")\r\n\r\n        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)\r\n        self.textBrowser_2.setGeometry(QtCore.QRect(160, 485, 191, 31))\r\n        self.textBrowser_2.setObjectName(\"textBrowser_2\")\r\n\r\n        self.label_image = QtWidgets.QLabel(self.centralwidget)\r\n        self.label_image.setGeometry(QtCore.QRect(450, 40, 512, 512))\r\n        self.label_image.setFrameShape(QtWidgets.QFrame.Box)\r\n        self.label_image.setObjectName(\"label_image\")\r\n        self.label_image.setScaledContents(True)  # 图片填充整个框\r\n\r\n        MainWindow.setCentralWidget(self.centralwidget)\r\n        self.menubar = QtWidgets.QMenuBar(MainWindow)\r\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 26))\r\n        self.menubar.setObjectName(\"menubar\")\r\n        MainWindow.setMenuBar(self.menubar)\r\n        self.statusbar = QtWidgets.QStatusBar(MainWindow)\r\n        self.statusbar.setObjectName(\"statusbar\")\r\n        MainWindow.setStatusBar(self.statusbar)\r\n\r\n        self.retranslateUi(MainWindow)\r\n        QtCore.QMetaObject.connectSlotsByName(MainWindow)\r\n\r\n        # self.pushButton.clicked.connect(self.openImage)\r\n\r\n        self.label_imagePath = QtWidgets.QLabel(self.centralwidget)\r\n        # self.label_imagePath.setGeometry(QtCore.QRect(570, 60, 150, 100))\r\n        self.label_imagePath.setObjectName(\"label_imagePath\")\r\n        self.label_imagePath.setWordWrap(True)\r\n\r\n        self.pushButton_saveImage.clicked.connect(self.saveImage)\r\n        self.pushButton_compress.clicked.connect(self.compress)\r\n\r\n    def retranslateUi(self, MainWindow):\r\n        _translate = QtCore.QCoreApplication.translate\r\n        MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\"))\r\n        # self.pushButton.setText(_translate(\"MainWindow\", \"选择图片\"))\r\n        self.pushButton_compress.setText(_translate(\"MainWindow\", \"开始压缩\"))\r\n        self.pushButton_saveImage.setText(_translate(\"MainWindow\", \"保存图片\"))\r\n        self.label.setText(_translate(\"MainWindow\", \"最小长度\"))\r\n        # self.label_imagethen.setText(_translate(\"MainWindow\", \"压缩后预览\"))\r\n        self.label_2.setText(_translate(\"MainWindow\", \"平均每个像素所需要的存储位数\"))\r\n        self.label_image.setText(_translate(\"MainWindow\", \"压缩后浏览\"))  # 其实是前\r\n\r\n    def openImage(self):  # 选择本地图片上传\r\n        global imgName  # 这里为了方便别的地方引用图片路径，我们把它设置为全局变量\r\n        imgName, imgType = QFileDialog.getOpenFileName(self.centralwidget, \"打开图片\", \"\",\r\n                                                       \"*.jpg;;*.png;;All Files(*)\")  # 弹出一个文件选择框，第一个返回值imgName记录选中的文件路径+文件名，第二个返回值imgType记录文件的类型\r\n        jpg = QtGui.QPixmap(imgName).scaled(self.label_image.width(),\r\n                                            self.label_image.height())  # 通过文件路径获取图片文件，并设置图片长宽为label控件的长宽\r\n        self.label_image.setPixmap(jpg)  # 在label控件上显示选择的图片\r\n        self.label_imagePath.setText(imgName)  # 显示所选图片的本地路径\r\n        return imgName\r\n\r\n    def saveImage(self):  # 保存图片到本地\r\n        screen = QApplication.primaryScreen()\r\n        pix = screen.grabWindow(self.label_image.winId())\r\n        fd, type = QFileDialog.getSaveFileName(self.centralwidget, \"保存图片\", \"\", \"*.jpg;;*.png;;All Files(*)\")\r\n        pix.save(fd)\r\n\r\n    def printf(self, mes):\r\n        self.textBrowser.append(mes)  # 在指定的区域显示提示信息\r\n        self.cursot = self.textBrowser.textCursor()\r\n        self.textBrowser.moveCursor(self.cursot.End)\r\n        # QtWidgets.QApplication.processEvents()\r\n\r\n    def printf2(self, mes2):\r\n        self.textBrowser_2.append(mes2)  # 在指定的区域显示提示信息\r\n        self.cursot2 = self.textBrowser.textCursor()\r\n        self.textBrowser.moveCursor(self.cursot2.End)\r\n\r\n    def compress(self):  # 压缩图片\r\n        self.openImage()\r\n        print(imgName)\r\n        img = cv2.imread(imgName)\r\n        test = CompressPic(img)\r\n        test.compressPic()  # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n        compress_rate = test.getCompressRate()  # 获取压缩效率\r\n        running_time = test.getRunningTime()  # 获取执行时间\r\n        min_length = test.getminlen()\r\n        aver_bit = test.getaverbit()\r\n        print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n        print(\"压缩算法执行时间：\" + str(running_time))\r\n        print(\"最小长度：\" + str(min_length))\r\n        print(\"平均每个像素：\" + str(aver_bit))\r\n        Ui_MainWindow.printf(self, str(min_length))\r\n        Ui_MainWindow.printf2(self, str(aver_bit))\r\n\r\n\r\nif __name__ == '__main__':\r\n    # 执行ui界面\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    formObj = QtWidgets.QMainWindow()\r\n    ui = Ui_MainWindow()\r\n    ui.setupUi(formObj)\r\n    formObj.show()\r\n    sys.exit(app.exec_())\r\n\r\n    # compress test\r\n    # img = cv2.imread(imgName, 0)\r\n    # # print(\"img array: \")\r\n    # # print(img)\r\n    # # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n    #\r\n    # # 压缩调用示例如下\r\n    # test = CompressPic(img)\r\n    # test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n    # compress_rate = test.getCompressRate()  # 获取压缩效率\r\n    # running_time = test.getRunningTime()  # 获取执行时间\r\n    # print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n    # print(\"压缩算法执行时间：\" + str(running_time))\r\n"
        }
    ]
}