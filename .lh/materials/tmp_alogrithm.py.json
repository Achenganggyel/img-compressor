{
    "sourceFile": "materials/tmp_alogrithm.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1684582261363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1684582299268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,9 +162,9 @@\n         将压缩信息输出到output/result.txt文件中\r\n     '''\r\n     def out(self, m, min_len, l, b):\r\n         i = 0\r\n-        f = open(\"result.txt\", \"w\")\r\n+        f = open(\"result.txt\", \"w+\")\r\n         f.seek(0)  # 定位到文件开头的位置\r\n         f.truncate()  # 清空原有内容\r\n         f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n         f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n@@ -212,9 +212,9 @@\n 功能入口\r\n '''\r\n if __name__ == '__main__':\r\n     # compress test\r\n-    img = cv2.imread(\"output/test1.jpg\", 0)\r\n+    img = cv2.imread(\"../output/test1.jpg\", 0)\r\n     # print(\"img array: \")\r\n     # print(img)\r\n     # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n \r\n"
                },
                {
                    "date": 1684582307004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,9 +212,9 @@\n 功能入口\r\n '''\r\n if __name__ == '__main__':\r\n     # compress test\r\n-    img = cv2.imread(\"../output/test1.jpg\", 0)\r\n+    img = cv2.imread(\"../pic/test1.jpg\", 0)\r\n     # print(\"img array: \")\r\n     # print(img)\r\n     # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n \r\n"
                },
                {
                    "date": 1684582342751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -212,9 +212,9 @@\n 功能入口\r\n '''\r\n if __name__ == '__main__':\r\n     # compress test\r\n-    img = cv2.imread(\"../pic/test1.jpg\", 0)\r\n+    img = cv2.imread(\"../\", 0)\r\n     # print(\"img array: \")\r\n     # print(img)\r\n     # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n \r\n"
                }
            ],
            "date": 1684582261363,
            "name": "Commit-0",
            "content": "'''\r\n对图像进行压缩的软件\r\n@Authors: \r\n    Alla, ytding, xx, xx\r\n@class\r\n    CompressPic 压缩图片的过程\r\n    Process 图像处理过程：将图片和np.ndarray间转换，保存图片和预览\r\n\r\n!!Attention!!\r\n如果修改了函数的输入输出，请在注释中写明\r\n因为没写过这个软件的完整版，多有疏漏，请多包涵qwq\r\n'''\r\nimport sys\r\nimport numpy as np\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton\r\nimport time\r\nimport cv2   # pip install opencv-python==4.5.4.58 -i https://pypi.douban.com/simple\r\n\r\n'''\r\n图像压缩类\r\n@params\r\n    in_pic_array(np.ndarray类型) 输入的512*512灰度图像转为的数组\r\n@return\r\n    compress_rate 压缩效率(getCompressRate函数)\r\n    running_time 执行时间(getRunningTime函数)\r\n'''\r\nclass CompressPic():\r\n    def __init__(self, input_pic=None) -> None:\r\n        self.input_pic = input_pic\r\n        self.N = 512\r\n        self.n = 512*512+1\r\n        self.compress_rate = None\r\n        self.running_time = None\r\n\r\n    '''\r\n    获得蛇形序列函数\r\n    @return\r\n        snake_order(list) 512*512灰度图像转为的数组的一维蛇形序列\r\n    '''\r\n    def getSnakeOrder(self):\r\n        snake_order = []  # 创建一个空列表，用于存储输出结果\r\n        snake_order.append(0)  # 下标从1开始\r\n        flag = 1  # 用于控制蛇形输出的方向\r\n        # 遍历图像的每一行\r\n        for i in range(self.N):\r\n            # 如果方向标志为1，则从左往右遍历该行的像素\r\n            if flag == 1:\r\n                for j in range(self.N):\r\n                    snake_order = np.append(snake_order, self.input_pic[i][j])  # 将该像素添加到输出数组中\r\n                flag = -1  # 改变方向标志，以便下一行从右往左遍历\r\n            # 如果方向标志为-1，则从右往左遍历该行的像素\r\n            else:\r\n                for j in range(self.N-1, -1, -1):\r\n                    snake_order = np.append(snake_order, self.input_pic[i][j])  # 将该像素添加到输出数组中\r\n                flag = 1  # 改变方向标志，以便下一行从左往右遍历\r\n        # print(\"p array:\")\r\n        # print(snake_order)\r\n        # test\r\n        # arr = np.array([[1, 2, 3, 3], [1, 2, 3, 4], [1, 3, 3, 2], [1, 2, 3, 4]])\r\n        # snake_order = []\r\n        # snake_order.append(0)\r\n        # flag = 1  # 用于控制蛇形输出的方向\r\n        # # 遍历图像的每一行\r\n        # for i in range(4):\r\n        #     # 如果方向标志为1，则从左往右遍历该行的像素\r\n        #     if flag == 1:\r\n        #         for j in range(4):\r\n        #             snake_order = np.append(snake_order, arr[i][j])  # 将该像素添加到输出数组中\r\n        #         flag = -1  # 改变方向标志，以便下一行从右往左遍历\r\n        #     # 如果方向标志为-1，则从右往左遍历该行的像素\r\n        #     else:\r\n        #         for j in range(3, -1, -1):\r\n        #             snake_order = np.append(snake_order, arr[i][j])  # 将该像素添加到输出数组中\r\n        #         flag = 1  # 改变方向标志，以便下一行从左往右遍历\r\n        # print(\"p array:\")\r\n        # print(snake_order)\r\n        return snake_order  # 返回包含所有像素的数组\r\n\r\n    '''\r\n        计算像素点所需要的存储位数\r\n        @params \r\n            i  像素点在p序列中的下标\r\n        @return\r\n            k 像素点所需要的存储位数\r\n            '''\r\n    def length(self, i):\r\n        k = 1\r\n        i = i/2\r\n        while i>0:\r\n            k += 1\r\n            i = i//2\r\n        return k\r\n\r\n    '''\r\n        基于动态规划的图像压缩算法\r\n        @params \r\n            n  像素点的个数+1\r\n            p(np.ndarray) 512*512灰度图像转为的数组的一维蛇形序列\r\n            s(list)  s[i]记录前i个数字的最优处理方式得到的最优解\r\n            b(list)  b[i]记录第i段每个像素的位数\r\n            l(list)   l[i]记录第i段有多少个像素\r\n        @return\r\n            s(list)\r\n        '''\r\n    def compress(self, n, p, s, b, l):\r\n        lmax = 256  # 每段所包含元素的最大个数\r\n        header = 11  # 段首大小\r\n        start_time = time.time()  # 记录开始执行时间\r\n        s[0] = 0\r\n        for i in range(1, n+1):\r\n            b[i] = self.length(p[i])\r\n            bmax = b[i]\r\n            s[i] = s[i - 1] + bmax + header\r\n            l[i] = 1\r\n            for j in range(2, lmax+1):\r\n                if j <= i:\r\n                    if bmax < self.length(p[i-j+1]):\r\n                        bmax = self.length(p[i-j+1])\r\n                    if s[i] > s[i-j] + j * bmax + header:\r\n                        s[i] = s[i - j] + j * bmax + header\r\n                        l[i] = j\r\n                        b[i] = bmax\r\n        # print(\"compress l array：\")\r\n        # print(l)\r\n        # print(\"b array：\")\r\n        # print(b)\r\n        # print(\"s array: \")\r\n        # print(s)\r\n        self.running_time = time.time() - start_time\r\n        input_size = 512 * 512 * 8\r\n        output_size = s[self.n - 1]\r\n        self.compress_rate = output_size / input_size\r\n        return s\r\n\r\n    '''\r\n        计算压缩后有多少段\r\n         @params \r\n            n  像素点的个数+1\r\n            b(list)  b[i]记录第i段每个像素的位数\r\n            l(list)   l[i]记录第i段有多少个像素\r\n        @return\r\n            i-1  压缩后的段数\r\n    '''\r\n    def traceBack(self, n, l, b):\r\n        stack = []\r\n        stack.append(l[n])\r\n        stack.append(b[n])\r\n        while n != 0:\r\n            n = n - l[n]\r\n            stack.append(l[n])\r\n            stack.append(b[n])\r\n        i = 0\r\n        while len(stack) > 0:\r\n            b[i] = stack[-1]\r\n            stack.pop()\r\n            l[i] = stack[-1]\r\n            stack.pop()\r\n            i += 1\r\n        return i-1\r\n\r\n    '''\r\n        将压缩信息输出到output/result.txt文件中\r\n    '''\r\n    def out(self, m, min_len, l, b):\r\n        i = 0\r\n        f = open(\"result.txt\", \"w\")\r\n        f.seek(0)  # 定位到文件开头的位置\r\n        f.truncate()  # 清空原有内容\r\n        f.write(\"最小长度：\" + str(min_len) + \"\\n\")\r\n        f.write(\"平均每个像素所需要的存储位数：\" + str(min_len / (512 * 512)) + \"\\n\")\r\n        f.write(\"共分成\" + str(m) + \"段\" + \"\\n\")\r\n        for i in range(i + 1, m + 1):\r\n            f.write(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素\\t\\t\" + \"需要存储的位数为：\" + str(b[i]) + \"\\n\")\r\n        f.close()\r\n        # print(\"最小长度：\" + str(min_len))\r\n        # print(\"平均每个像素所需要的存储位数：\" + str(min_len/(512*512)))\r\n        # print(\"共分成\" + str(m) + \"段\")\r\n        # for i in range(i+1, m+1):\r\n        #     print(\"第\" + str(i) + \"段含有\" + str(l[i]) + \"个元素     \" + \"需要存储的位数为：\" + str(b[i]))\r\n\r\n    '''\r\n        对图像进行压缩\r\n    '''\r\n    def compressPic(self):\r\n        if self.input_pic is None:\r\n            raise ValueError(\"Input picture is not provided\")\r\n        p = self.getSnakeOrder()  # 获取一维蛇形序列\r\n        # p = [0, 255, 1, 5, 2, 1, 2]  # test\r\n        s = [0]*self.n  # 记录前i个数字的最优处理方式得到的最优解\r\n        b = [0]*self.n  # 记录第i段每个像素的位数\r\n        l = [0]*self.n  # 记录第i段有多少个像素\r\n        # print(\"图像的灰度序列为：\")\r\n        # for i in range(1, self.n):\r\n        #     print(str(p[i]) + \" \")\r\n        s = self.compress(self.n-1, p, s, b, l)\r\n        m = self.traceBack(self.n-1, l, b)\r\n        self.out(m, s[self.n-1], l, b)\r\n\r\n    '''\r\n        返回压缩效率\r\n    '''\r\n    def getCompressRate(self):\r\n        return self.compress_rate\r\n\r\n    '''\r\n        返回压缩算法执行时间\r\n    '''\r\n    def getRunningTime(self):\r\n        return self.running_time\r\n\r\n'''\r\n功能入口\r\n'''\r\nif __name__ == '__main__':\r\n    # compress test\r\n    img = cv2.imread(\"output/test1.jpg\", 0)\r\n    # print(\"img array: \")\r\n    # print(img)\r\n    # np.savetxt(\"output/beforeCompress.txt\", img, fmt='%d', delimiter=',')\r\n\r\n    # 压缩调用示例如下\r\n    test = CompressPic(img)\r\n    test.compressPic()   # 调用算法进行压缩，压缩结果保存在output/result.txt文件中\r\n    compress_rate = test.getCompressRate()  # 获取压缩效率\r\n    running_time = test.getRunningTime()  # 获取执行时间\r\n    print(\"压缩算法压缩效率：\" + str(compress_rate))\r\n    print(\"压缩算法执行时间：\" + str(running_time))\r\n\r\n\r\n\r\n"
        }
    ]
}